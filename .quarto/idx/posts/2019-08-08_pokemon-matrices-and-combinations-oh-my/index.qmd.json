{"title":"What Types Should You Have on Your Pokémon Team? Efficient Simulation with Matrices in R","markdown":{"yaml":{"title":"What Types Should You Have on Your Pokémon Team? Efficient Simulation with Matrices in R","date":"2019-08-20","slug":"pokemon-type-combinations","categories":["R","Code"],"description":"Finding the best Pokémon type combinations for a maximally effective team."},"headingText":"Data Exploration","containsRefs":false,"markdown":"\n\nI recently started playing Pokémon again - [\"Pokémon Let's Go Eevee\"](https://www.amazon.com/Pokémon-Lets-Go-Eevee-Switch/dp/B01N7RE3HB) on the Nintendo Switch to be specific. In the classic Pokémon games, you have a team of 6 Pokémon that you use to battle against other trainers. In battles, type match-ups are very important, as some types of moves are \"super effective\" against other types. For example, fire moves are super effective against grass Pokémon, which means they do double the damage they normally would. If you can set your team up so that you're always optimally matched, you're going to have a much easier time. \n\nBut there are 18 types and you only get 6 Pokémon on your team. This leads to the question - what are the combinations of 6 types that make you super effective against the most types of Pokémon?<sup>1</sup> It turns out this is a question [a lot of people have asked](https://www.google.com/search?q=what+Pokémon+team+will+make+you+super+effetive+against+everything&oq=what+Pokémon+team+will+make+you+super+effetive+against+everything&aqs=chrome..69i57.6074j0j7&sourceid=chrome&ie=UTF-8).\n\nI knew there was a chart out there that matches up every attacking type against every defending and tells you whether they're super effective, normal, not very effective, or doesn't have any effect. So I decided to use my R skills to answer this question (many thanks to my brother [David Robinson](http://varianceexplained.org/) for his guidance at various points). Along the way, we'll do a quick exploratory analysis, learn about combinatorials, and leave the tidyverse to use matrices and some base functions.\n\n\nI found a csv of the Pokémon type chart on GitHub. Using `read_csv()` on the url didn't work, and rather than try to debug it, I decided to \"cheat\"\" and use the magic package [`datapasta` package](https://github.com/MilesMcBain/datapasta). On Github, I clicked to edit the file, copied everything in it, and then used `tribble_paste()`, which output my clipboard into the code that would create a tibble I called `type_comparisons`. \n\n[Added 8/26]: As [Jim Hester](https://twitter.com/jimhester_) kindly pointed out, `read_csv()` will work if I use it on the raw link, generated by clicking the \"Raw\" button. \n\n```{r message = FALSE, warning = FALSE}\nlibrary(tidyverse)\n# this didn't work\n# type_comparisons <- read_csv(\"https://github.com/robinsones/pokemon-chart/blob/master/chart.csv\")\n```\n\n```{r}\nlibrary(datapasta)\n# use tribble_paste()\ntype_comparisons <- tibble::tribble(\n     ~Attacking, ~Normal, ~Fire, ~Water, ~Electric, ~Grass, ~Ice, ~Fighting, ~Poison, ~Ground, ~Flying, ~Psychic, ~Bug, ~Rock, ~Ghost, ~Dragon, ~Dark, ~Steel, ~Fairy,\n       \"Normal\",       1,     1,      1,         1,      1,    1,         1,       1,       1,       1,        1,    1,   0.5,      0,       1,     1,    0.5,      1,\n         \"Fire\",       1,   0.5,    0.5,         1,      2,    2,         1,       1,       1,       1,        1,    2,   0.5,      1,     0.5,     1,      2,      1,\n        \"Water\",       1,     2,    0.5,         1,    0.5,    1,         1,       1,       2,       1,        1,    1,     2,      1,     0.5,     1,      1,      1,\n     \"Electric\",       1,     1,      2,       0.5,    0.5,    1,         1,       1,       0,       2,        1,    1,     1,      1,     0.5,     1,      1,      1,\n        \"Grass\",       1,   0.5,      2,         1,    0.5,    1,         1,     0.5,       2,     0.5,        1,  0.5,     2,      1,     0.5,     1,    0.5,      1,\n          \"Ice\",       1,   0.5,    0.5,         1,      2,  0.5,         1,       1,       2,       2,        1,    1,     1,      1,       2,     1,    0.5,      1,\n     \"Fighting\",       2,     1,      1,         1,      1,    2,         1,     0.5,       1,     0.5,      0.5,  0.5,     2,      0,       1,     2,      2,    0.5,\n       \"Poison\",       1,     1,      1,         1,      2,    1,         1,     0.5,     0.5,       1,        1,    1,   0.5,    0.5,       1,     1,      0,      2,\n       \"Ground\",       1,     2,      1,         2,    0.5,    1,         1,       2,       1,       0,        1,  0.5,     2,      1,       1,     1,      2,      1,\n       \"Flying\",       1,     1,      1,       0.5,      2,    1,         2,       1,       1,       1,        1,    2,   0.5,      1,       1,     1,    0.5,      1,\n      \"Psychic\",       1,     1,      1,         1,      1,    1,         2,       2,       1,       1,      0.5,    1,     1,      1,       1,     0,    0.5,      1,\n          \"Bug\",       1,   0.5,      1,         1,      2,    1,       0.5,     0.5,       1,     0.5,        2,    1,     1,    0.5,       1,     2,    0.5,    0.5,\n         \"Rock\",       1,     2,      1,         1,      1,    2,       0.5,       1,     0.5,       2,        1,    2,     1,      1,       1,     1,    0.5,      1,\n        \"Ghost\",       0,     1,      1,         1,      1,    1,         1,       1,       1,       1,        2,    1,     1,      2,       1,   0.5,      1,      1,\n       \"Dragon\",       1,     1,      1,         1,      1,    1,         1,       1,       1,       1,        1,    1,     1,      1,       2,     1,    0.5,      0,\n         \"Dark\",       1,     1,      1,         1,      1,    1,       0.5,       1,       1,       1,        2,    1,     1,      2,       1,   0.5,      1,    0.5,\n        \"Steel\",       1,   0.5,    0.5,       0.5,      1,    2,         1,       1,       1,       1,        1,    1,     2,      1,       1,     1,    0.5,      2,\n        \"Fairy\",       1,   0.5,      1,         1,      1,    1,         2,     0.5,       1,       1,        1,    1,     1,      1,       2,     2,    0.5,      1\n     )\n```\n\nTo make it easier to explore the data, I'm going to start by tidying it. \n\n```{r}\ntidied_comparison <- type_comparisons %>%\n  gather(Defending, outcome, -Attacking)\n\ntidied_comparison %>%\n  slice(103:109) %>%\n  knitr::kable()\n```\n\nWe now have a dataset of 324 rows, with each Attacking-Defending combination and what the outcome is. Here, outcome is 2 if it's super effective (what we're interested in), 1 if normal, .5 if not very effective, and 0 if no effect. \n\nWhat types are super effective against the most other types?\n\n```{r}\ntidied_comparison %>%\n  group_by(Attacking) %>%\n  summarize(nb_super_effective = sum(ifelse(outcome == 2, 1, 0))) %>%\n  arrange(desc(nb_super_effective)) %>%\n  knitr::kable()\n```\n\nFighting and Ground are both super effective against 5 different types, while Normal isn't super effective against any. \n\nAre there any types where only one Attacking type is super-effective? \n\n```{r}\ntidied_comparison %>%\n  filter(outcome == 2) %>%\n  add_count(Defending) %>%\n  arrange(n) %>%\n  head(4) %>%\n  knitr::kable()\n```\n\nYes - if we want to be super effective against Normal and Electric types, we need Fighting and Ground types respectively. \n  \n\n## Building Pokémon Teams\n\nThe first step is to build out all the hypothetical teams of 6. If you remember your introduction to statistics days, this is a combinatorial problem: we have 18 options (although we don't expect \"Normal\" to show up since it's not super effective against anything), need to choose 6, and the order doesn't matter (e.g. 1 to 6 is the same as 6 to 1). We can do this in R with the function `combn`:\n\n```{r}\nall_combinations <- combn(18, 6)\ndim(all_combinations)\n```\n\n`all_combinations` is a 6 by 18,564 matrix: each column is a different combination of types. For example, let's look at the first two columns: \n\n```{r}\nall_combinations[, 1:2]\n```\n\nThe first column is one team with the types 1 through 6, while the second is a team with 1 through 5 and 7. \n\nNow we need to take this and understand how many types each team is super effective against.\n\n## Matrix Magic\n\nI originally was thinking of calling this post \"Going back to the Base[ics],\" since I'm moving out of the tidyverse and into the world of matrices, but there's really nothing basic about this. Let's walk through it step by step. \n\nFirst, we're going to take our table and make it a matrix. We can't just do `as.matrix()` directly, as it will make the Attacking column the first column, while we want that to be the rownames, so we'll do it in two steps.\n\n```{r}\nm <- as.matrix(type_comparisons[, -1])\nrownames(m) <- type_comparisons$Attacking\n```\n\nNext, because we only care about whether the entry is 2 or not, we'll change every entry that's a 2 to be 1 and every entry that's not to be 0 (the `1L *` makes it 1 or 0 instead of TRUE or FALSE). \n\n```{r}\nsuper_effective_m <- (m == 2) * 1L\n```\n\n```{r}\nsuper_effective_m\n```\n\nThe `all_combinations` matrix we created before is essentially a set of indices for the `super_effective_m` matrix. For example, column 1 of `all_combinations` are the numbers 1 through 6, which means we want to get rows 1 through 6 of `super_effective_m`. Remember, each row of `super_effective_m` is an attacking type on our team, and each column is a defending type. We then want to get the sum of each column and know how many columns have a sum of more than 0, meaning at least one of our attacking types was super effective against it. We'll make a function, `super_effective_nb`:\n\n```{r}\nsuper_effective_nb <- function(indices) {\n  sum(colSums(super_effective_m[indices, ]) > 0)\n}\n```\n\nNow we can use `apply()` to get a vector, for all 18k+ teams, of how many types they're super effective against. If you're not familiar with `apply()`, the first argument is what we're applying our function to, the second is whether it should apply to the rows or columns (we choose 2 for column, since each column is the team), and the third is the function.\n\n```{r}\nsuper_effective_results <- apply(all_combinations, 2, super_effective_nb)\n```\n\nWhat are the combinations that are super effective against the maximum number of types possible? \n\n```{r}\nwhich(super_effective_results == max(super_effective_results))\n```\n\nWe see there are 10 possible combinations of six types. Let's take a look at them by getting those columns from `all_combinations`. \n\n```{r}\nbest_combos <- all_combinations[, super_effective_results == max(super_effective_results)]\nbest_combos\n```\n\nWe now have a matrix, `best_combo`, where each column is a team. For example, we see a team of types 4, 6, 7, 9, 10, and 14 cover the maximum number of defending types. But what is type 4? To answer that, we take the row names from `super_effective_m` and index it by `best_combos`. \n\n```{r}\nrownames(super_effective_m)[best_combos]\n```\n\nThis gets us a character vector though. It's in order, so we know that the first six is team 1, the second six team 2, etc., but it's not displayed very well. We can use `matrix` to turn this into a matrix instead, specifying that we want 6 rows. \n\n```{r}\nstrongest_teams <- matrix(rownames(super_effective_m)[best_combos], nrow = 6)\n```\n\n```{r}\nstrongest_teams\n```\n\nFor our final step, we're actually going to make this a tibble, so I can look at which types appear the most often across the different team possibilities. \n\n```{r warning = FALSE}\nstrongest_teams %>%\n  as_tibble() %>%\n  gather(team, type) %>%\n  count(type, sort = TRUE) %>%\n  knitr::kable()\n```\n\nWe see all 10 of the teams need a ground type, where 8 have a Fighting, Flying, or Ice type. On the other hand, Electric, Fairy, Rock, and Steel are only each used by two teams. \n\n## Conclusion \n\nWhile this is a bit of a silly use case, the code we walked through and lessons learned could be applied to a lot of different projects. When I advise people to make a portfolio of data science projects if they're looking for a job, I sometimes get asked, \"But how do I find something to work on?\" I recommend looking in your own life and interests where you could use data science. If you're a runner and use an activity tracker, graph how your run distances and times are related to the weather. If you're active on a subreddit, you could use the reddit API to get the last 500 posts and do a text analysis. The possibilities are limitless! \n\nI also played around with getting this code even faster and trying to do everything in a tidy way instead. Including those methods made the post run a little too long, so I may follow up with a part 2 of this post. To make this analysis more useful, I could also take into account how common types are - for example, only a few Pokémon have a Dragon type, so it's less important to have types that are super effective against Dragon. \n\n[1] Pokémon players will know that you can have more than 6 types on your team, both because some Pokémon have two types and because Pokémon can learn moves of other types (e.g. a Normal type Pokémon may be able to learn a Dark move). But for the purposes of this analysis I simplified it. \n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.242","theme":"cosmo","title-block-banner":true,"author":[{"name":"Emily Robinson"}],"toc-title":"Table of contents","toc-location":"left","title":"What Types Should You Have on Your Pokémon Team? Efficient Simulation with Matrices in R","date":"2019-08-20","slug":"pokemon-type-combinations","categories":["R","Code"],"description":"Finding the best Pokémon type combinations for a maximally effective team."},"extensions":{"book":{"multiFile":true}}}}}